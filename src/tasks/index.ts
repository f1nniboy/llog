import { AnyChannel, Channel, Collection, Guild, Message, User } from "discord.js-selfbot-v13";
import { randomUUID } from "crypto";
import { basename } from "path";
import chalk from "chalk";


import { App } from "../app.js";
import { Utils } from "../util/utils.js";

export interface ScheduledTask {
    id: string;

    /** When this task should be run, absolute Unix timestamp */
    time: number;

    /** Which task handler to use */
    type: string;

    /** Additional context for the task */
    context: RawTaskContext;
}

interface RawTaskContext {
    channelId: string;

    /** Optional, as the bot works in DMs */
    guildId?: string;

    /** Which user to interact with specifically */
    userId?: string;
    
    /** Which message to interact with specifically */
    messageId?: string;
    
    /** Instructions generated by AI to be used later on, when the task runs */
    instructions?: string;

    /** Other parameters */
    triggered?: boolean;
}

export interface TaskContext {
    channel: AnyChannel;
    guild?: Guild;
    user?: User;
    message?: Message;
    instructions?: string;
    triggered?: boolean;
}

type ScheduleTaskOptions = Pick<ScheduledTask, "time" | "type" | "context">

export interface TaskRunOptions {
    task: ScheduledTask;
    context: TaskContext;
}

export interface TaskCheckOptions {
    context: RawTaskContext;
}

interface TaskHandlerData {
    /** Internal name of the task handler */
    name: string;

    settings: {
        /** Maximum amount of tasks of type to queue */
        maxQueue: number;
    }
}

export abstract class TaskHandler {
    protected readonly app: App;

    /** Information about the task handler & its parameters */
    public readonly options: TaskHandlerData;

    constructor(app: App, options: TaskHandlerData) {
        this.app = app;
        this.options = options;
    }

    /**
     * Run this task with the given context.
     * @param options ...
     */
    public abstract run(options: TaskRunOptions): Promise<void>;

    /**
     * Check whether this task should be added to the queue in the first place.
     * @param options ...
     * @returns Whether the task should be added to the queue
     */
    public check(options: TaskCheckOptions): boolean {
        return true;
    }
}

export class TaskManager {
    public readonly app: App;

    private readonly handlers: Collection<string, TaskHandler>;
    private readonly queue: Collection<string, ScheduledTask>;
    private current: ScheduledTask | undefined;

    private timeout: NodeJS.Timeout | undefined;

    constructor(app: App) {
        this.app = app;

        this.handlers = new Collection();
        this.queue = new Collection();
    }

    /**
     * Schedule a task to be run in the future.
     * @param task Data about the task
     */
    public async add(options: ScheduleTaskOptions) {
        const existingTasks = this.getTasksByType(options.type);
        const handler = this.getHandlerByType(options.type);

        if (existingTasks.size >= handler.options.settings.maxQueue)
            return undefined;

        if (!handler.check({
            context: options.context
        })) return undefined;

        const id = this.randomId();

        const task: ScheduledTask = {
            ...options, id
        };

        this.scheduleQueue(task);
        this.queue.set(id, task);

        return task;
    }

    public clearForGuild(guildId: string, type?: string) {
        const ids = this.queue.filter(
            t => (t.context.guildId && t.context.guildId == guildId)
                    && type ? t.type == type : false
        );

        for (const id of ids.keys()) {
            this.queue.delete(id);
        }
    }

    private scheduleQueue(task?: ScheduledTask) {
        if (this.current !== undefined) return;
        const now = Date.now();

        const sorted = this.sortTasksByTime();
        const nearTask = sorted.at(0);

        let time = 1234;

        /* No new task queued, so we finished the current queue entry,
           and want to wait for the next entry */
        if (!task && nearTask) {
            time = Math.max(nearTask.time - now, 0);
        }

        /* If no new task was queued and the queue is empty, we idle */
        if (!task && !nearTask) return;

        /* There's no other task in the queue and we want to schedule a new one */
        if (!nearTask && task) {
            time = Math.max(task.time - now, 0);
        }

        /* If there is a task in the queue and we want to add a new one, ... */
        if (nearTask && task) {
            /* If the new task runs earlier than the task in the queue, ... */
            if (nearTask && nearTask.time > task.time) {
                time = Math.max(task.time - now, 0);
            }
        }

        if (this.timeout) clearTimeout(this.timeout);

        this.timeout = setTimeout(
            () => this.handleQueue(),
            time
        );
    }

    public async handleQueue(): Promise<void> {
        /* Grab the first available task, sorted by scheduled time */
        const task = this.sortTasksByTime()[0];
        const handler = this.getHandlerByType(task.type);

        try {
            this.current = task;
            this.queue.delete(task.id);

            await this.process(handler, task);
        } catch (error) {
            this.app.logger.error(chalk.bold("An error occured while processing the task queue"), "->", error);
        } finally {
            this.current = undefined;
            this.scheduleQueue();
        }
    }

    private async process(handler: TaskHandler, task: ScheduledTask) {
        this.app.logger.debug(`Running task type ${chalk.bold(task.type)} ...`);

        const context = await this.fetchTaskContext(task.context);

        await handler.run({
            task, context
        });

        this.app.logger.debug(`Ran task type ${chalk.bold(task.type)}.`);
    }

    private async fetchTaskContext({ channelId, guildId, messageId, userId, instructions, triggered }: RawTaskContext): Promise<TaskContext> {
        const channel = await this.app.client.channels.fetch(channelId);
        if (!channel) throw new Error("This shouldn't happen at all");

        const guild = guildId ? await this.app.client.guilds.fetch(guildId) : undefined;

        const user = guild && userId ? (await guild.members.fetch(userId)).user : undefined;

        return {
            channel, guild, user,
            message: messageId && channel.isText() ? await channel.messages.fetch(messageId) : undefined,
            instructions, triggered
        };
    }

    public async load(): Promise<void> {
        const files: string[] = await Utils.search("./build/tasks");
        
        await Promise.all(files.map(async path => {
            const name: string = basename(path).split(".")[0];

            await import(path)
                .then((data: { [key: string]: TaskHandler }) => {
                    const handler: TaskHandler = new (data.default as any)(this.app);
                    this.handlers.set(handler.options.name, handler);
                })
                .catch(error => this.app.logger.warn("Failed to load task handler", chalk.bold(name), "->", error));
        }));

        this.app.logger.debug("Loaded", chalk.bold(this.handlers.size), "task handlers.");
    }

    private sortTasksByTime(): ScheduledTask[] {
        return Array.from(this.queue.values())
            .sort((a, b) => a.time - b.time);
    }

    private getTasksByType(type: string) {
        return this.queue.filter(t => t.type == type);
    }

    private getHandlerByType(type: string): TaskHandler {
        if (!this.handlers.has(type)) throw new Error("This shouldn't happen");
        return this.handlers.get(type)!;
    }

    private randomId() {
        return randomUUID();
    }
}